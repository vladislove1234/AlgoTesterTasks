// File generated by dotnet-combine at 2023-09-19__22_48_03

using AlgoTester.Helpers;
using static AlgoTester.Helpers.ConsoleHelper;
using static System.Console;
using System;
using System.Collections.Generic;
using System.IO;
using System.Linq;
using System.Net.Http;
using System.Threading;
using System.Threading.Tasks;


// Program.cs
namespace AlgoTester.Trilandia
{
    public static class Program
    {
        private const int ErrorAnswer = -1;
        private const string DefaultSeparator = " ";

        public static void Main()
        {
            
                var trianglesCount = ReadInt();

                var startEndPoints = ReadInts(2);

                var startPoint = startEndPoints[0] - 1;
                var endPoint = startEndPoints[1] - 1;

                var points = ReadItems(trianglesCount * 3, str =>
                {
                    var coordinates = str.Split(DefaultSeparator)
                        .Select(float.Parse)
                        .ToArray();

                    return new Point(coordinates[0], coordinates[1], coordinates[2]);
                }).ToArray();
                
                if(startPoint == endPoint)
                {
                    WriteLine(0);
                    return;
                }

                var sideToNeighbourSides = GetSideToNeighbourSides(points, 
                    startPoint,
                    endPoint,
                    out HashSet<Side> start,
                    out HashSet<Side> end);
                
                var queue = new Queue<Side>(start);
                var visited = new HashSet<Side>(start);

                bool isWayFound = false;
                
                var way = new List<Tuple<Side, Side>>();

                if (start.Any(end.Contains))
                {
                    WriteLine(1);
                }

                while (queue.Count > 0)
                {
                    var currItem = queue.Dequeue();

                    var children = sideToNeighbourSides[currItem]
                        .Where(x => !visited.Contains(x));
                    
                    foreach (var child in children)
                    {
                        visited.Add(child);
                        queue.Enqueue(child);
                        
                        way.Add(new Tuple<Side, Side>(currItem, child));
                        
                        if (end.Contains(child))
                        {
                            queue.Clear();

                            isWayFound = true;
                            
                            break;
                        }
                    }
                }
                
                if(!isWayFound)
                {
                    WriteLine(ErrorAnswer);
                    return;
                }

                var currentPair = way.Last();

                var pathLength = 2;

                while (!start.Contains(currentPair.Item1))
                {
                    currentPair = way.First(x => x.Item2.Equals(currentPair.Item1));

                    pathLength++;
                }

                WriteLine(pathLength);
        }

        private static Dictionary<Side, HashSet<Side>> GetSideToNeighbourSides(Point[] points, 
            int startPoint,
            int endPoint,
            out HashSet<Side> startSides,
            out HashSet<Side> endSides)
        {
            var sideToNeighbourSides = new Dictionary<Side, HashSet<Side>>();

            startSides = Enumerable.Empty<Side>().ToHashSet();
            endSides = Enumerable.Empty<Side>().ToHashSet();
            
            for (int i = 0; i < points.Length / 3; i++)
            {
                var point1 = points[i * 3];
                var point2 = points[i * 3 + 1];
                var point3 = points[i * 3 + 2];

                var side1 = new Side(point1, point2);
                var side2 = new Side(point2, point3);
                var side3 = new Side(point3, point1);
                
                if(i == startPoint)
                {
                    startSides = new HashSet<Side>(){side1, side2, side3};
                }
                else if(i == endPoint)
                {
                    endSides = new HashSet<Side>(){side1, side2, side3};
                }
                
                sideToNeighbourSides.AddOrCreateList(side1, side2, side3);
                sideToNeighbourSides.AddOrCreateList(side2, side1, side3);
                sideToNeighbourSides.AddOrCreateList(side3, side2, side1);
            }

            return sideToNeighbourSides;
        }
        
        private static void AddOrCreateList<T>(this Dictionary<T, HashSet<T>> dictionary, T key, params T[] value)
        {
            if (dictionary.TryGetValue(key, out var hashSet))
            {
                foreach (var item in value)
                {
                    hashSet.Add(item);
                }
            }
            else
            {
                dictionary[key] = new HashSet<T>(value);
            }
        }
    }

    public struct Point
    {
        public float X { get; }

        public float Y { get; }

        public float Z { get; }
        
        public Point(float x, float y, float z)
        {
            X = x;
            Y = y;
            Z = z;
        }

        public static bool IsSmaller(Point a, Point b)
        {
            return a.Y < b.Y;
        }

        public override int GetHashCode()
        {
            return HashCode.Combine(X, Y, Z);
        }
    }
    
    public struct Side : IEquatable<Side>
    {
        public Point StartPoint;

        public Point EndPoint;

        public Side(Point start, Point end)
        {
            StartPoint = Point.IsSmaller(start, end) ? start : end;
            EndPoint = Point.IsSmaller(start, end) ? end : start;
        }

        public override int GetHashCode()
        {
            return StartPoint.GetHashCode() + EndPoint.GetHashCode();
        }

        public bool Equals(Side other)
        {
            var aHash = GetHashCode();

            var bHash = other.GetHashCode();

            var isEqual = aHash == bHash;

            return isEqual;
        }
    }
}