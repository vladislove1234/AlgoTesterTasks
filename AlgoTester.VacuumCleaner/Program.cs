// File generated by dotnet-combine at 2023-09-19__22_48_03

using AlgoTester.Helpers;
using static AlgoTester.Helpers.ConsoleHelper;
using static System.Console;
using System;
using System.Collections.Generic;
using System.IO;
using System.Linq;
using System.Net.Http;
using System.Threading;
using System.Threading.Tasks;

namespace AlgoTester.VacuumCleaner
{
    public static class Program
    {
        public static void Main()
        {
            var size = ReadInts(2);

            var x = size[1];
            var y = size[0];

            var points = new HashSet<Point>();

            for (int i = 0; i < y; i++)
            {
                var line = ReadLine().ToArray();

                for (int j = 0; j < x; j++)
                {
                    if (line[j] == '*')
                    {
                        points.Add(new Point(j, i));
                    }
                }
            }

            var pointsCount = points.Count;

            points.Add(new Point(0, 0));

            /*var graph = new int[points.Count][];

            for (int i = 0; i < points.Count; i++)
            {
                graph[i] = new int[points.Count];

                for (int j = 0; j < points.Count; j++)
                {
                    graph[i][j] = points[i].GetDistance(points[j]);
                }
            }*/

            var path = FindShortestPath(points, new Point(0,0));

            var length = 0;

            for (int i = 1; i < path.Length; i++)
            {
                var from = path[i - 1];
                var to = path[i];

                length += from.GetDistance(to);
            }

            length += pointsCount;

            WriteLine(length);
        }

        public static Point[] FindShortestPath(HashSet<Point> points, Point start)
        {
            var queue = new PriorityQueue<Point,int>();
            var paths = new Dictionary<Point, List<Point>>();
            var distancesFromStart = new Dictionary<Point, int>();

            var visited = new HashSet<Point>();
            
            var pointsCount = points.Count;

            queue.Enqueue(start,0);

            paths[start] = new List<Point>()
            {
                start
            };
            
            var prices = new Dictionary<Point, int>();
            
            prices[start] = 0;
            distancesFromStart[start] = 0;
            visited.Add(start);

            var lastPoint = start;
            var foundLastPoint = false;

            while (queue.Count > 0)
            {
                var current = queue.Dequeue();

                var currentPath = paths[current];

                var currentLength = currentPath.Count;

                if (currentLength == pointsCount)
                {
                    lastPoint = current;
                    break;
                }

                foreach (var point in points)
                {
                    if (current.Equals(point) || point.Equals(start))
                    {
                        continue;
                    }

                    int remainedArea = GetArea(points.Except(currentPath.Append(point)));

                    int currPrice = remainedArea + distancesFromStart[current] + current.GetDistance(point); 

                    if (prices.TryGetValue(point, out var pointPrice))
                    {
                        if (currPrice < pointPrice)
                        {
                            prices[point] = currPrice;
                            queue.Enqueue(point, currPrice);
                            paths[point] = currentPath.Append(point).ToList();
                            distancesFromStart[point] = distancesFromStart[current] + current.GetDistance(point);
                        }
                    }
                    else
                    {
                        prices[point] = currPrice;
                        queue.Enqueue(point, currPrice);
                        paths[point] = currentPath.Append(point).ToList();
                        distancesFromStart[point] = distancesFromStart[current] + current.GetDistance(point);
                    }
                }
            }

            var path = paths[lastPoint];

            return path.ToArray();
        }

        private static int GetArea(IEnumerable<Point> points)
        {
            int minX = int.MaxValue, minY= int.MaxValue, maxX= int.MinValue, maxY = int.MinValue;

            foreach (var point in points)
            {
                if (point.X < minX)
                {
                   minX = point.X;
                }

               if (point.X > maxX)
               {
                   maxX = point.X;
               }

               if (point.Y < minY)
               {
                   minY = point.Y;
               }

               if (point.Y > maxY)
               {
                   maxY = point.Y;
               }

            }
            
           var Xrange = Math.Max(maxX - minX + 1,1);
           var Yrange = Math.Max(maxY - minY + 1,1);

           return Xrange * Yrange;
        }

        public static int PrimMSTLength(int startPoint, int[][] graph, bool[] visited)
        {
            var mstVisited = new bool[visited.Length];
            mstVisited[startPoint] = true;
            int length = 0;

            while (mstVisited.Count(x => x) + visited.Count(x => x) != visited.Length)
            {
                int minLength = int.MaxValue, minPoint = -1;
                
                for(int i = 0; i < graph.Length; i++)
                {
                    if (!mstVisited[i])
                    {
                        continue;
                    }

                    for (int j = 0; j < graph.Length; j++)
                    {
                        if (mstVisited[j] || visited[j])
                        {
                            continue;
                        }

                        var distance = graph[i][j];

                        if (distance < minLength)
                        {
                            minLength = distance;
                            minPoint = j;
                        }
                    }
                }

                mstVisited[minPoint] = true;
                length += minLength;
            }

            return length;
        }

        public struct Point : IEquatable<Point>
        {
            public int X { get; }
            public int Y { get; }

            public Point(int x, int y)
            {
                X = x;
                Y = y;
            }

            public int GetDistance(Point other)
            {
                return Math.Abs(X - other.X) + Math.Abs(Y - other.Y);
            }

            public bool Equals(Point other)
            {
                return X == other.X && Y == other.Y;
            }

            public override bool Equals(object? obj)
            {
                if (obj is Point p)
                {
                    return X == p.X && Y == p.Y;
                }

                return false;
            }

            public override int GetHashCode()
            {
                return HashCode.Combine(X, Y);
            }
        }
    }
}