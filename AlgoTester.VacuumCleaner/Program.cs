// File generated by dotnet-combine at 2023-09-19__22_48_03

using AlgoTester.Helpers;
using static AlgoTester.Helpers.ConsoleHelper;
using static System.Console;
using System;
using System.Collections.Generic;
using System.IO;
using System.Linq;
using System.Net.Http;
using System.Threading;
using System.Threading.Tasks;

namespace AlgoTester.VacuumCleaner
{
    public static class Program
    {
        public static void Main()
        {
            var size = ReadInts(2);

            var x = size[1];
            var y = size[0];

            var points = new HashSet<Point>();

            for (int i = 0; i < y; i++)
            {
                var line = ReadLine().ToArray();

                for (int j = 0; j < x; j++)
                {
                    var point = new Point(j, i);
                    
                    if (line[j] == '*')
                    {
                        point.IsDirty = true;
                    }

                    points.Add(point);
                }
            }

            var pointsCount = points.Count;

            var path = FindShortestPath(points, points.First(p => p.Y == 0 && p.X == 0));

            var length = path.Length - 1 + points.Count(p => p.IsDirty);

            WriteLine(length);
        }

        public static Point[] FindShortestPath(HashSet<Point> points, Point start)
        {
            var queue = new AlgoTester.Helpers.PriorityQueue<Point>();
            var paths = new Dictionary<Point, List<Point>>();
            var distancesFromStart = new Dictionary<Point, int>();

            var visited = new HashSet<Point>();
            
            var pointsCount = points.Count;
            var dirtyPoints = points.Count(p => p.IsDirty);

            queue.Enqueue(start,0);

            paths[start] = new List<Point>()
            {
                start
            };
            
            var prices = new Dictionary<Point, int>();
            
            prices[start] = 0;
            distancesFromStart[start] = 0;
            visited.Add(start);

            var lastPoint = start;
            var foundLastPoint = false;

            while (queue.Count > 0)
            {
                var current = queue.Dequeue();

                var currentPath = paths[current];
                
                if(current.IsDirty && currentPath.Count(p => p.IsDirty) == dirtyPoints)
                {
                    lastPoint = current;
                    foundLastPoint = true;
                    break;
                }

                var neighbours = GetNeighbours(current, points);

                foreach (var point in neighbours)
                {
                    int currPrice = (int)(currentPath.Count + 1 + PrimMSTLength(point, points, currentPath.Append(point).ToHashSet()) * 1.5);

                    if (prices.TryGetValue(point, out var pointPrice))
                    {
                        if (currPrice < pointPrice)
                        {
                            prices[point] = currPrice;
                            queue.Enqueue(point, currPrice);
                            paths[point] = currentPath.Append(point).ToList();
                        }
                    }
                    else
                    {
                        prices[point] = currPrice;
                        queue.Enqueue(point, currPrice);
                        paths[point] = currentPath.Append(point).ToList();
                    }
                }
            }

            var path = paths[lastPoint];

            return path.ToArray();
        }

        private static Point[] GetNeighbours(Point current, HashSet<Point> points)
        {
            var neighbours = new List<Point>();

            var up = points.FirstOrDefault(p => p.X == current.X && p.Y == current.Y - 1);
            var down = points.FirstOrDefault(p => p.X == current.X && p.Y == current.Y + 1);
            var left = points.FirstOrDefault(p => p.X == current.X - 1 && p.Y == current.Y);
            var right = points.FirstOrDefault(p => p.X == current.X + 1 && p.Y == current.Y);

            if (points.Contains(up))
            {
                neighbours.Add(up);
            }

            if (points.Contains(down))
            {
                neighbours.Add(down);
            }

            if (points.Contains(left))
            {
                neighbours.Add(left);
            }

            if (points.Contains(right))
            {
                neighbours.Add(right);
            }

            return neighbours.ToArray();
        }

        public static int PrimMSTLength(Point startPoint, HashSet<Point> graph, HashSet<Point> visited)
        {
            var mstVisited = new HashSet<Point>();
            mstVisited.Add(startPoint);
            int length = 0;

            var dirtyPoints = graph.Where(p => p.IsDirty).Except(visited).Append(startPoint).ToHashSet();

            //find mst from dirty points, calculate distnce by method in Point GetDistance and don't look for neighbours as all points are neighbours to eac other
            while (mstVisited.Count < dirtyPoints.Count)
            {
                var minDistance = int.MaxValue;
                Point minPoint = new Point(0, 0);
                foreach (var point in mstVisited)
                {
                    foreach (var otherPoint in dirtyPoints)
                    {
                        if (mstVisited.Contains(otherPoint))
                        {
                            continue;
                        }

                        var distance = point.GetDistance(otherPoint);

                        if (distance < minDistance)
                        {
                            minDistance = distance;
                            minPoint = otherPoint;
                        }
                    }
                }

                length += minDistance;
                mstVisited.Add(minPoint);
            }

            return length;
        }

        public struct Point : IEquatable<Point>
        {
            public int X { get; }
            public int Y { get; }
            
            public bool IsDirty { get; set; }

            public Point(int x, int y)
            {
                X = x;
                Y = y;

                IsDirty = false;
            }

            public int GetDistance(Point other)
            {
                return Math.Abs(X - other.X) + Math.Abs(Y - other.Y);
            }

            public bool Equals(Point other)
            {
                return X == other.X && Y == other.Y;
            }

            public override int GetHashCode()
            {
                return HashCode.Combine(X, Y);
            }
        }
    }
}